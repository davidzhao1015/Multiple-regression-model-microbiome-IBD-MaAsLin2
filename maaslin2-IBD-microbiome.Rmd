---
title: "Multivariable regression of microbiome and IBD using MaAsLin2 R package"
author: "David Xin Zhao"
date: "Last edited `r format(Sys.time(), '%d %B %Y')`"
knit: (function(inputFile, encoding) { 
      out_dir <- 'docs';
      rmarkdown::render(inputFile,
                        encoding=encoding, 
                        output_file=file.path(dirname(inputFile), out_dir, 'index.html'))}) 
output:
  html_document:
    df_print: paged
    theme: united
    highlight: tango
    # css: styles.css 
    toc: true
    toc_float: true
     # collapsed: false
     # smooth_scroll: false 
  toc_depth: 2
  number_sections: true
  fig_width: 7
  fig_height: 6
  fig_caption: true
  df_print: paged
---

```{=html}
<style>
#TOC{
 color: #7E7C73;
 font-family: Calibri;
 font-size: 16px;
 border-color: #BBC4C2;
}
h1.title{
 color: #140005;
 background-color: #F5F5F5;
 opacity: 0.6;
 font-family: Calibri;
 font-size: 30px;
}
h4.author{
 color: #464033;
 font-family: Calibri;
 font-size: 25px;
}
h4.date{
 color: #464033;
 font-family:Calibri; 
}
body{
 color: #464033; 
 font-family: Calibri; 
 background-color: #F5F5F5;
}
pre{
 color: #464033;
 background-color: #FFFFFF;
}
</style>
```
```{r setup, include = FALSE}
# set options for the entire document 
knitr::opts_chunk$set(fig.align = 'center', 
                      echo=TRUE, #display code in output document 
                      error=FALSE,
                      message=FALSE) #stop render when error occurs   
```

## Install MaAsLin2 with Bioconductor

```{r message=FALSE}

# if(!requireNamespace("BiocManager", quietly = TRUE))
#     install.packages("BiocManager")
# BiocManager::install("Maaslin2")

library(Maaslin2)
library(tidyverse)
library(knitr)
library(janitor)
library(lazyeval)
library(rlang)
library(rmarkdown) #create paged tables 

```

## Multiple regression of microbiome and clincial covariates of interest

### Load data sets (use example datasets provided by MaAsLin2 package)

```{r include=FALSE}

# set file pathway to abundance data 
input_data <- system.file("extdata",
                          "HMP2_taxonomy.tsv",
                          package="Maaslin2") # the abundance table file 

# set file pathway to meta data 
input_metadata <- system.file("extdata",
                              "HMP2_metadata.tsv",
                              package = "Maaslin2")  # the metadata table file 

# # get the pathway (functional) data 
# download.file("https://raw.githubusercontent.com/biobakery/biobakery_workflows/master/examples/tutorial/stats_vis/input/pathabundance_relab.tsv", "./pathabundance_relab.tsv")

```

```{r message=FALSE, results='hide', collapse=TRUE}
 
# relative abundance data 
df_input_data <- read.table(file = input_data,
                            header = TRUE,
                            sep = "\t",
                            row.names = 1,
                            stringsAsFactors = FALSE) 

# meta data 
df_input_metadata <- read.table(file=input_metadata,
                                header = T,
                                sep="\t",
                                row.names = 1,
                                stringsAsFactors = F) 

# pathway data 
df_input_path <- data.frame(read.csv("./pathabundance_relab.tsv", 
                                     sep = "\t", 
                                     stringsAsFactors = F, 
                                     row.names = 1))

```

### Exploratory data analysis

```{r EDA, echo=FALSE}

# descriptive stats for top 20 abundant genus 
df_input_data_long <- df_input_data %>%
  rownames_to_column("sample") %>%
  gather(key="genus", value="rel_abund", -sample) 

summary_genus <- df_input_data_long %>% 
  group_by(genus) %>%
  summarise(average = mean(rel_abund, na.rm=TRUE)*100,
            std = sd(rel_abund, na.rm=TRUE)*100,
            zero_rate = mean(rel_abund == 0)*100)%>%
  arrange(desc(average)) %>%
  head(20)  # top 20 genus based on average relative abundance 
```

```{r data table}
# display summary of relative abundance at genus level in a table 
knitr::kable(summary_genus, 
      col.names = c("Genus",
                    "Average percentage",
                    "Standard deviation",
                    "Zeroness percentage")) 
```

```{r descriptive stats for meta-data, echo=FALSE}

summary(df_input_metadata) #structure of metadata 

```

There were 11 covariates in mete-data as follows, 
`age`, `dysbiosis`, and `collection` were numerical variables; and `site`, `diagnosis`, `subject`, `antibiotics`, `dysbiosis_binary`, `dysbiosisnonIBD`, `dysbiosisUC`, `dysbiosisCD` were character variables. 

In addition,  missing values were present in three variables, `dysbiosisnonIBD`, `dysbiosisUC`, `dysbosisCD`. 

```{r convert to factor variables}

# convert some character variables to factor variables 
# diagnosis 
df_input_metadata$diagnosis <- factor(df_input_metadata$diagnosis, 
                                      levels = c("nonIBD", # set "nonIBD" a reference level 
                                                 "UC",
                                                 "CD"))
levels(df_input_metadata$diagnosis)  


# convert remaining character variables to binary factor variables  
df_input_metadata <- df_input_metadata %>% 
  mutate(site = factor(site),
         antibiotics = factor(antibiotics),  
         dysbiosis_binary = factor(dysbiosis_binary),
         dysbiosisnonIBD = factor(dysbiosisnonIBD),
         dysbiosisUC = factor(dysbiosisUC),
         dysbiosisCD = factor(dysbiosisCD)) 

summary(df_input_metadata) # investigate again the resulting meta-data 

```

Calculate median and IQR for numerical variables; and subtotal (percentages) for categorical variables. Conduct chi-square test on categorical variables and do ANOVA on numerical variables within each strata according to diagnosis.Use a table to display summary. 
```{r summary table for meta-data}

# site distribution by diagnosis levels 
df_site <- tabyl(df_input_metadata, site, diagnosis) %>% 
  adorn_totals(c("row", "col"))%>%
  adorn_percentages("row") %>% 
  adorn_pct_formatting(digits = 0) %>% 
  adorn_ns() %>%  # combine count and percentage 
  add_row(site = "site", 
          .before = 1) %>%  #add one row showing variable name 
  filter(row_number() !=7) #remove total row 
```

Follow the instruction in [programming with dyplyr](<https://dplyr.tidyverse.org/articles/programming.html>)
```{r build a function}

#write a function to generate a summary table for covariates 
count_pct <- function(x){
  data1 <- df_input_metadata %>% 
    tabyl(., .data[[x]], diagnosis) %>% #follow the website, "programming with dplyr"  
    adorn_totals(c("row", "col"))%>%
    adorn_percentages("row") %>% 
    adorn_pct_formatting(digits = 0) %>% 
    adorn_ns()
  
  addrow <- data.frame(colnames(data1)[1], NA, NA, NA, NA)
  
  names(addrow) <- colnames(data1)
  
  data2 <- rbind(addrow, data1) 
  
  names(data2)[1] <- "covariable" 
  
  data2 %>%
    filter(row_number() != n())
} 

count_pct("site")  #the function works properly  


```

Apply the function to multiple categorical variables. Subset only categorical variables from `df_input_metadata`. 
```{r}
cat_cov <- df_input_metadata %>% 
  select(where(is.factor)) %>% 
  select(-diagnosis) %>% 
  colnames()

sum_cat <- lapply(cat_cov, count_pct) #list of summary of multiple categorical variables  

# combine each element of the list by rows before storing in a data frame 
df_sum_cat <- as.data.frame(do.call(rbind, sum_cat))

```


```{r, results='hide'}

str(df_input_metadata)

numerical_summary <- function(x){
dat_ns <- df_input_metadata %>% 
  group_by(diagnosis) %>% 
  summarise(average = round(mean(.data[[x]], na.rm=T),2),
            std = round(sd(.data[[x]], na.rm = T),2)) %>% 
  select(-average)
  
df_num_sub <- df_input_metadata %>% 
  group_by(diagnosis) %>% 
  summarise(average = round(mean(.data[[x]], na.rm=T),2)) %>%
  adorn_ns(ns = dat_ns)%>% 
  rename("average (sd)"= average) %>%
  spread(key=diagnosis, value = "average (sd)") %>% 
  mutate(covariable = x) %>% 
  select(covariable, 1:3)


total_dat_ns <- df_input_metadata %>%
  summarise(average = round(mean(.data[[x]], na.rm=T),2),
            std = round(sd(.data[[x]], na.rm = T),2)) %>%
  select(-average) %>%
  mutate(covariable = x) %>% 
  select(covariable, std)
  
df_num <- df_input_metadata %>%
  summarise(average = round(mean(.data[[x]], na.rm=T),2)) %>%
  mutate(covariable = x) %>% 
  select(covariable, average) %>% 
  adorn_ns(ns = total_dat_ns) %>% 
  rename("average (sd)" = average)

df_num_bind <- cbind(df_num_sub, df_num[,2]) 

colnames(df_num_bind)[5] <- "overall"

print(df_num_bind) 
}

numerical_summary("age") #the resulting function works properly

```

Apply the function `numerical_summary` to all the numerical variables in meta-data with `lapply`.  
```{r}
# extract column names for all the numerical variables in meta-data 
num_names <- df_input_metadata %>% 
  select(where(is.numeric)) %>% 
  colnames()

list_num_summary <- lapply(num_names, numerical_summary) 
  
str(list_num_summary)

# convert individual element of the list to data frames and bind them into a single data frame 
df_num_summary <- as.data.frame(do.call(rbind, list_num_summary)) 

```

Combine descriptive stats tables, `df_sum_cat` and `df_num_summary` for categorical and numerical covariables, respectively  
```{r}
head(df_sum_cat, 3)
head(df_num_summary, 3)


names(df_sum_cat)[5] <- "overall"  #rename the column name

df_all_cov <- bind_rows(df_sum_cat, df_num_summary) #bind by rows 

#replace NA in the column, "co variable" with " unknown"
df_all_cov$covariable <- as.character(df_all_cov$covariable)
df_all_cov$covariable %>% replace_na("unknown")  

```

Apply chi-square test and ANOVA to categorical descriptive stats and numerical descriptive stats, respectively 
```{r}

# write a function to do chi-square to categorical variables 
chi_square <- function(x){
  chisq <- chisq.test(df_input_metadata[[x]], df_input_metadata$diagnosis)
  
  pval <- chisq$p.value
  
  pval_digit <- format(round(pval, 3), nsmall=4)
  
  print(pval_digit)
  
}

chi_square("site")

df_pval_cat <- data.frame(covariable = cat_cov, 
                          pvalue = numeric(length = length(cat_cov)))   #create empty df to store p-values 

df_pval_cat$pvalue <- sapply(cat_cov, chi_square) 




#write a function to do anova to numerical variables against diagnosis 
anova_num <- function(x){
  f <- paste0(x, "~", "diagnosis")
  
  pval <- anova(lm(f, data=df_input_metadata))$"Pr(>F)"[1]
  
  pval_digit <- format(round(pval, 3), nsmall=5)
  
  print(pval_digit)
}


df_pval_num <- data.frame(covariable = num_names, 
                          pvalue = numeric(length = length(num_names)))   #create empty df to store p-values 

df_pval_num$pvalue <- sapply(num_names, anova_num) 



#join p-values with descriptive stats table 
df_all_cov_pval <- df_all_cov %>% 
  left_join(df_pval_num, by="covariable") %>% 
  left_join(df_pval_cat, by="covariable")  

df_all_cov_pval$pvalue.x <- if_else(!is.na(df_all_cov_pval$pvalue.x), 
                            df_all_cov_pval$pvalue.x,
                            df_all_cov_pval$pvalue.y)  

df_all_cov_pval$covariable <- if_else(!is.na(df_all_cov_pval$covariable), 
                            df_all_cov_pval$covariable,
                            "unknown")  

df_all_cov_pval2 <- df_all_cov_pval %>% select(-pvalue.y) %>% rename(pvalue = pvalue.x) 

df_all_cov_pval2 #view the resulting table

```


```{r}
# descriptive stats of pathway data set 
transp_input_path <- data.frame(t(df_input_path)) # transpose df 

transp_input_path_long <- transp_input_path %>%
  rownames_to_column("sample") %>%
  gather(key="pathway", value="rel_abund", -sample) # reshape to a long format 

summary_path <- transp_input_path_long %>% 
  group_by(pathway) %>%
  summarise(average = mean(rel_abund, na.rm=TRUE),
            std = sd(rel_abund, na.rm=TRUE),
            zero_rate = mean(rel_abund == 0)*100)%>%
  arrange(desc(average)) %>%
  head(20)  # top 20 pathways based on average relative abundance 

knitr::kable(summary_path, 
      col.names = c("Pathway",
                    "Average",
                    "Standard deviation",
                    "Zeroness percentage")) 
```

### Fit mutiple linear regression model on microbiome data

The following command runs MaAsLin2 on the HMP2 data, running a multivariable regression model to test for the association between microbial species abundance versus IBD diagnosis and dysbiosis scores.
```{r message=FALSE,results='hide',collapse=TRUE}
fit_data2 <- Maaslin2(
        input_data = df_input_data,
        input_metadata = df_input_metadata,
        min_prevalence = 0, #without additional filtering 
        normalization = "NONE",  #without additional normalization  
        output = "demo_output2",
        max_significance = 0.1,
        plot_heatmap = FALSE,
        plot_scatter = FALSE,
        analysis_method = "LM",  #linear regression model 
        fixed_effects = c("diagnosis", "dysbiosis"),  #set diagnosis and dysbiosis as fixed effect variables 
        reference = c("diagnosis,nonIBD")) #set the baseline for the categorical variable, diagnosis 

all_results <- fit_data2$results #extract coefficients and q-value

```

### Evaluate significant genus based on model parameters

significant associations is provided in 'significant_results.tsv'

```{r}
sig_results <- all_results %>% 
        filter(qval <= 0.05) %>% #sig threshold 
        arrange(qval)

head(sig_results, 5) #view first rows 

```

### Fit multivariable regression models on functional data

Authors tend to work with CPM units because we find them to be more convenient, but they are numerically equivalent to relative abundances for modeling purposes (CPM = RA \* 1e6)

Quick tips for using MaAsLin2 on functional profiles: 1.To reduce the number of features, you typically want to run either the unstratified functional features ( or a filtered subset of the stratified features) 2.You may also want to remove functional features that are highly correlated to one specific taxon (i.e. likely contributed by that microbe), since these can be better-explained by taxonomic changes
```{r normalization, message=FALSE}

#This can also be done with with the HUMAnN 3 untiliy `humann_split_stratified_table`
unstrat_pathways <-function(dat_path){
  temp = dat_path[!grepl("\\|",rownames(dat_path)),]
  return(temp)
}

df_input_path = unstrat_pathways(df_input_path)

```

Run the same model as above on the MetaCyc pathway table generated from the bioBakery workflows.

```{r message=FALSE,results='hide',collapse=TRUE}
# fit the model on pathway (functional) data - it takes a few minutes  
fit_func <- Maaslin2(
        input_data = df_input_path,
        input_metadata = df_input_metadata,
        output = "demo_functional",
        fixed_effects = c("diagnosis", "dysbiosis"),
        reference=c("diagnosis,nonIBD"),
        min_abundance = 0.0001,
        min_prevalence = 0.1) 

# note: here we have the samples in the columns and the features in the rows and MaAsLin2 correctly identified this and was able to match the samples. 

all_results_func <- fit_func$results

```

### Interactions

Unfortunately, MaAsLin2 does not yet provide a direct interface for testing for interaction. Instead, the user needs to create artificial interaction columns as additional 'fixed_effects' terms.

Using the above fit as an example, to test for the interaction between 'diagnosis' and 'dysbiosis', I can create two additional columns: 'CD_dysbiosis' and 'UC_dysbiosis' (since the reference for 'diagnosis' is 'nonIBD'):
```{r interaction term, message=FALSE,results='hide',collapse=TRUE}

df_input_metadata$CD_dysbiosis <- (df_input_metadata$diagnosis == "CD") * df_input_metadata$dysbiosis

df_input_metadata$UC_dysbiosis <- (df_input_metadata$diagnosis == "UC") * df_input_metadata$dysbiosis

fit_data_interaction <- Maaslin2(
        input_data = df_input_data,
        input_metadata = df_input_metadata,
        min_prevalence = 0,
        normalization = "NONE",
        output = "demo_output_interaction",
        fixed_effects = c("diagnosis", "dysbiosis", "CD_dysbiosis", "UC_dysbiosis"),
        reference = c("diagnosis,nonIBD")) 

all_results_interaction <- fit_data_interaction$results  # store results 

```

### Random effects

We note that HMP2 is a longitudinal design where the same subject (column 'subject') can have multiple samples. We thus ask MaAsLin2 to use subject as its random effect grouping variable:
```{r mixed effect model, message=FALSE,results='hide',collapse=TRUE}

fit_data_random <- Maaslin2(
        input_data = df_input_data,
        input_metadata = df_input_metadata,
        min_prevalence = 0,
        normalization = "NONE",
        output = "demo_output_random",
        fixed_effects = c("diagnosis", "dysbiosis"),
        random_effects = c("subject"),
        reference = c("diagnosis,nonIBD")
)

all_results_random <- fit_data_random$results

```

If you are interested in testing the effect of time in a longitudinal study, then the itme point variable should be included in 'fixed_effects' during your MaAsLin2 call.

### Prevalence and abundance filtering in MaAsLin2

minimum prevalence threshold: 10-50% (up to 70-90% can be reasonable) minimum relative abundance threshold: 0.0001
```{r prevalence and abundance filtering, message=FALSE,results='hide',collapse=TRUE}

fit_data_filter = Maaslin2(
    input_data = df_input_data, 
    input_metadata = df_input_metadata, 
    normalization = "NONE",
    output = "demo_output_filter", 
    fixed_effects = c("diagnosis", "dysbiosis"),
    reference = c("diagnosis,nonIBD"),
    random_effects = c("subject"),
    min_prevalence = 0.1,
    min_abundance = 0.0001)

```
